name: Sync All Repos to Gitee
# 同步功能模块化：
# 将代码同步、标签同步和附件同步功能拆分为独立函数：
# sync_code(): 只同步分支代码
# sync_tags(): 只同步标签
# sync_releases(): 同步发布版本和附件
# 触发方式和同步模式：
# 自动触发（schedule）：
# 每3天自动执行一次
# 默认只同步代码（SYNC_MODE=code_only）
# 手动触发（workflow_dispatch）：
# 提供三种同步模式选项：
# code_only: 只同步源码
# code_and_tags: 同步源码和标签
# code_tags_and_assets: 同步源码、标签和附件
on:
  workflow_dispatch:
    inputs:
      sync_mode:
        description: '同步模式 / Sync Mode'
        required: true
        default: 'code_only'
        type: choice
        options:
        - code_only
        - code_and_tags
        - code_tags_and_assets
  schedule:
    - cron: '0 0 */3 * *'  # 每3天执行一次

# MYGITEE_TOKEN 是 gitee 的 token
# MYGITEE_USERNAME 是 gitee 的 用户名
# MYGITHUB_TOKEN 是 github 的 token
jobs:
  sync-to-gitee:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.MYGITHUB_TOKEN }}
      GITEE_TOKEN: ${{ secrets.MYGITEE_TOKEN }}
      GITEE_USERNAME: ${{ secrets.MYGITEE_USERNAME }}
      # 设置同步模式：自动触发时只同步代码
      SYNC_MODE: ${{ github.event_name == 'schedule' && 'code_only' || github.event.inputs.sync_mode }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -t rsa gitee.com >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts

    - name: Setup SSH key with ssh-agent
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.MYGITEE_SSH_PRIVATE_KEY }}
        
    - name: Test SSH Connection
      run: ssh -T git@gitee.com || true

    - name: Setup Git and Verify Tokens
      id: verify_tokens
      run: |
        git config --global user.name "github_bot"
        git config --global user.email "github_bot@github.com"
        
        echo "Verifying GitHub Token and counting repositories..."
        github_repos_count=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
          "https://api.github.com/user/repos?per_page=1" -I | grep -i "link:" | grep -o "page=[0-9]*" | tail -1 | cut -d= -f2)
        if [ -z "$github_repos_count" ]; then
          echo "Error: Unable to get GitHub repositories count. Token may be invalid."
          exit 1
        fi
        echo "Found $github_repos_count repositories on GitHub"
        echo "GITHUB_REPOS_COUNT=$github_repos_count" >> $GITHUB_ENV
        
        echo "Verifying Gitee Token and counting repositories..."
        gitee_repos_count=$(curl -s -H "Authorization: token $GITEE_TOKEN" \
          "https://gitee.com/api/v5/user/repos?per_page=1" -I | grep -i "total_count:" | cut -d: -f2 | tr -d ' \r\n')
        if [ -z "$gitee_repos_count" ]; then
          echo "Error: Unable to get Gitee repositories count. Token may be invalid."
          exit 1
        fi
        echo "Found $gitee_repos_count repositories on Gitee"
        echo "GITEE_REPOS_COUNT=$gitee_repos_count" >> $GITHUB_ENV

    - name: Sync Repositories
      run: |
        # 清理函数
        cleanup() {
          local repo_path=$1
          echo "清理临时文件和目录 / Cleaning up temporary files and directories..."
          if [ -d "$repo_path" ]; then
            cd "$repo_path"
            git gc --prune=now
            cd ..
            rm -rf "$repo_path"
          fi
          # 清理所有临时文件
          rm -f /tmp/*.apk /tmp/*.zip /tmp/*.tar.gz /tmp/*.jar 2>/dev/null || true
          echo "✅ 清理完成 / Cleanup completed"
          # 显示剩余磁盘空间
          echo "剩余磁盘空间 / Remaining disk space:"
          df -h /tmp
        }

        # 获取可见引用函数（排除隐藏引用）
        get_visible_refs() {
          local ref_type=$1  # "heads" 或 "tags"
          git for-each-ref --format='%(refname)' "refs/${ref_type}/*" | grep -v "refs/pull/" | grep -v "refs/gh-pages/"
        }

        # 推送单个引用函数（带重试机制）
        push_ref() {
          local repo_name=$1
          local ref=$2
          local max_retries=3
          local retry_count=0
          local success=false
          
          while [ $retry_count -lt $max_retries ] && [ "$success" = "false" ]; do
            if [ $retry_count -gt 0 ]; then
              echo "第 $((retry_count + 1)) 次尝试推送 / Retry attempt $((retry_count + 1)) for $ref"
              sleep $((retry_count * 5))  # 递增等待时间
            fi
            
            if timeout 300 git push -f "git@gitee.com:${GITEE_USERNAME}/${repo_name##*/}.git" "$ref:$ref" 2>&1; then
              success=true
              echo "✅ 成功推送 / Successfully pushed: $ref"
              break
            else
              retry_count=$((retry_count + 1))
              if [ $retry_count -lt $max_retries ]; then
                echo "⚠️ 推送失败，将重试 / Push failed, will retry: $ref"
              fi
            fi
          done
          
          if [ "$success" = "false" ]; then
            echo "❌ 推送失败（已重试 $max_retries 次）/ Push failed after $max_retries retries: $ref"
            return 1
          fi
          
          return 0
        }

        # 同步代码函数 - 只同步分支代码
        sync_code() {
          local repo_name=$1
          local repo_path=$2
          local ret=0
          local failed_refs=""
          
          echo "推送分支代码 / Pushing branch code..."
          get_visible_refs "heads" | while read ref; do
            echo "推送分支 / Pushing branch: $ref"
            if ! push_ref "$repo_name" "$ref"; then
              failed_refs="$failed_refs\n$ref"
              ret=1
              continue  # 继续处理其他分支，而不是立即退出
            fi
          done
          
          if [ -n "$failed_refs" ]; then
            echo "----------------------------------------"
            echo "❌ 以下分支推送失败 / Following branches failed to push:"
            echo -e "$failed_refs"
            echo "----------------------------------------"
          fi
          
          return $ret
        }

        # 同步标签函数
        sync_tags() {
          local repo_name=$1
          local repo_path=$2
          local ret=0
          local failed_refs=""
          
          echo "推送标签 / Pushing tags..."
          get_visible_refs "tags" | while read ref; do
            echo "推送标签 / Pushing tag: $ref"
            if ! push_ref "$repo_name" "$ref"; then
              failed_refs="$failed_refs\n$ref"
              ret=1
              continue  # 继续处理其他标签，而不是立即退出
            fi
          done
          
          if [ -n "$failed_refs" ]; then
            echo "----------------------------------------"
            echo "❌ 以下标签推送失败 / Following tags failed to push:"
            echo -e "$failed_refs"
            echo "----------------------------------------"
          fi
          
          return $ret
        }

        # 同步Release附件函数
        sync_releases() {
          local repo_name=$1
          
          echo "检查发布版本 / Checking releases for $repo_name..."
          # 获取GitHub的releases
          local releases=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${repo_name}/releases")
          
          # 检查是否有releases
          if [ "$(echo "$releases" | jq length)" -eq "0" ]; then
            echo "ℹ️ 未找到发布版本 / No releases found for $repo_name"
            return 0
          fi
          
          echo "在 GitHub 上找到 $(echo "$releases" | jq length) 个发布版本 / Found $(echo "$releases" | jq length) release(s) on GitHub"
          
          # 获取Gitee上已存在的releases
          local gitee_releases=$(curl -s -H "Authorization: token $GITEE_TOKEN" \
            "https://gitee.com/api/v5/repos/${GITEE_USERNAME}/${repo_name##*/}/releases?per_page=100")
          local existing_tags=$(echo "$gitee_releases" | jq -r '.[].tag_name' 2>/dev/null || echo "")
          
          # 并行处理releases
          echo "$releases" | jq -c '.[]' | while read -r release; do
            {
              local tag_name=$(echo "$release" | jq -r '.tag_name')
              local name=$(echo "$release" | jq -r '.name // .tag_name')
              local body=$(echo "$release" | jq -r '.body // ""')
              local prerelease=$(echo "$release" | jq -r '.prerelease')
              
              echo "处理发布版本 / Processing release: $tag_name"
              
              # 检查release是否已存在
              if echo "$existing_tags" | grep -q "^${tag_name}$"; then
                echo "ℹ️ 发布版本已存在于 Gitee / Release $tag_name already exists on Gitee"
              else
                process_release "$repo_name" "$tag_name" "$name" "$body" "$prerelease" "$release"
              fi
            } &
            
            # 限制并行数量为3个
            while [ $(jobs -r | wc -l) -ge 3 ]; do
              sleep 1
            done
          done
          
          # 等待所有release处理完成
          wait
          
          return 0
        }

        # 主同步函数
        sync_repo() {
          local repo_name=$1
          local repo_path=$2
          local gitee_repo_exists=$3
          local ret=0
          
          echo "===> 步骤 1: 克隆 GitHub 仓库 / Step 1: Cloning GitHub repository"
          echo "仓库 / Repository: $repo_name"
          
          # 使用完整克隆而不是浅克隆，避免 Gitee 拒绝推送
          git clone --mirror \
            "https://x-access-token:${GITHUB_TOKEN}@github.com/${repo_name}.git" "$repo_path" || {
            echo "❌ 从 GitHub 克隆仓库失败 / Failed to clone repository from GitHub: $repo_name"
            return 1
          }
          echo "✅ 成功克隆 GitHub 仓库 / Successfully cloned GitHub repository"
          
          cd "$repo_path"
          
          if [ "$gitee_repo_exists" = "false" ]; then
            echo "===> 步骤 2: 在 Gitee 上创建新仓库 / Step 2: Creating new repository on Gitee"
            echo "创建私有仓库 / Creating private repository: ${repo_name##*/}"
            local create_response=$(curl -s -X POST -H "Authorization: token $GITEE_TOKEN" \
              "https://gitee.com/api/v5/user/repos" \
              -d "name=${repo_name##*/}&private=true&has_issues=true&has_wiki=true")
            
            if echo "$create_response" | grep -q "error"; then
              echo "❌ 在 Gitee 上创建仓库失败 / Failed to create repository on Gitee: ${repo_name##*/}"
              echo "错误 / Error: $(echo "$create_response" | jq -r '.error // .message')"
              ret=1
            else
              echo "✅ 成功创建 Gitee 仓库 / Successfully created Gitee repository"
            fi
            
            echo "等待仓库创建完成 / Waiting for repository creation to complete..."
            sleep 5
          fi
          
          if [ $ret -eq 0 ]; then
            echo "===> 步骤 3: 同步到 Gitee / Step 3: Syncing to Gitee"
            
            # 根据同步模式执行不同的同步操作
            case "$SYNC_MODE" in
              "code_only")
                echo "仅同步代码 / Syncing code only..."
                sync_code "$repo_name" "$repo_path"
                ;;
              "code_and_tags")
                echo "同步代码和标签 / Syncing code and tags..."
                (sync_code "$repo_name" "$repo_path" && \
                sync_tags "$repo_name" "$repo_path") &
                ;;
              "code_tags_and_assets")
                echo "同步代码、标签和附件 / Syncing code, tags and assets..."
                (sync_code "$repo_name" "$repo_path" && \
                sync_tags "$repo_name" "$repo_path") &
                sync_releases "$repo_name" &
                ;;
            esac
            
            # 等待所有后台任务完成
            wait
          fi
          
          cd ..
          cleanup "$repo_path"
          return $ret
        }

        # 主程序
        processed=0
        total=$GITHUB_REPOS_COUNT
        page=1
        success_count=0
        failed_count=0
        max_concurrent_syncs=3  # 最大并行同步数量
        
        echo "开始仓库同步 / Starting repository synchronization..."
        
        while true; do
          echo "获取第 $page 页仓库 / Fetching page $page of repositories..."
          repos=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/user/repos?per_page=100&page=${page}")
          
          # 检查是否还有仓库
          if [ "$(echo "$repos" | jq length)" -eq "0" ]; then
            echo "没有更多仓库需要处理 / No more repositories to process"
            break
          fi
          
          # 获取Gitee现有仓库列表
          echo "获取 Gitee 仓库列表 / Fetching Gitee repository list..."
          gitee_repos=$(curl -s -H "Authorization: token $GITEE_TOKEN" \
            "https://gitee.com/api/v5/user/repos?per_page=100" | jq -r '.[].name')
          
          # 并行处理仓库
          echo "$repos" | jq -r '.[] | .full_name' | while read -r repo_name; do
            # 等待，直到运行中的任务数小于最大并行数
            while [ $(jobs -r | wc -l) -ge $max_concurrent_syncs ]; do
              sleep 1
            done
            
            repo_path="/tmp/$(basename "$repo_name")"
            
            echo "----------------------------------------"
            echo "处理第 $((processed + 1)) 个，共 $total 个 / Processing $((processed + 1)) of $total: $repo_name"
            
            # 检查仓库是否已存在于Gitee
            if echo "$gitee_repos" | grep -q "^$(basename "$repo_name")$"; then
              echo "仓库已存在于 Gitee / Repository exists on Gitee: ${repo_name##*/}"
              gitee_repo_exists=true
            else
              echo "仓库不存在于 Gitee / Repository does not exist on Gitee: ${repo_name##*/}"
              gitee_repo_exists=false
            fi
            
            # 在后台运行同步任务
            (
              if sync_repo "$repo_name" "$repo_path" "$gitee_repo_exists"; then
                echo "✅ 成功同步仓库 / Successfully synced repository: $repo_name"
                success_count=$((success_count + 1))
              else
                echo "❌ 同步仓库失败 / Failed to sync repository: $repo_name"
                failed_count=$((failed_count + 1))
              fi
            ) &
            
            processed=$((processed + 1))
          done
          
          # 等待当前页的所有任务完成
          wait
          
          page=$((page + 1))
        done
        
        echo "============================================"
        echo "同步完成 / Synchronization completed"
        echo "处理的仓库总数 / Total repositories processed: $processed"
        echo "成功数量 / Successful: $success_count"
        echo "失败数量 / Failed: $failed_count"
        echo "============================================"
        
        # 如果有失败的仓库，返回非零状态码
        [ "$failed_count" -eq 0 ]

name: Sync All Repos to Gitee
# 同步功能模块化：
# 将代码同步、标签同步和附件同步功能拆分为独立函数：
# sync_code(): 只同步分支代码
# sync_tags(): 只同步标签
# sync_releases(): 同步发布版本和附件
# 触发方式和同步模式：
# 自动触发（schedule）：
# 每3天自动执行一次
# 默认只同步代码（SYNC_MODE=code_only）
# 手动触发（workflow_dispatch）：
# 提供三种同步模式选项：
# code_only: 只同步源码
# code_and_tags: 同步源码和标签
# code_tags_and_assets: 同步源码、标签和附件
on:
  workflow_dispatch:
    inputs:
      sync_mode:
        description: '同步模式 / Sync Mode'
        required: true
        default: 'code_only'
        type: choice
        options:
        - code_only
        - code_and_tags
        - code_tags_and_assets
  schedule:
    - cron: '0 0 */3 * *'  # 每3天执行一次

# MYGITEE_TOKEN 是 gitee 的 token
# MYGITEE_USERNAME 是 gitee 的 用户名
# MYGITHUB_TOKEN 是 github 的 token
jobs:
  sync-to-gitee:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.MYGITHUB_TOKEN }}
      GITEE_TOKEN: ${{ secrets.MYGITEE_TOKEN }}
      GITEE_USERNAME: ${{ secrets.MYGITEE_USERNAME }}
      # 设置同步模式：自动触发时只同步代码
      SYNC_MODE: ${{ github.event_name == 'schedule' && 'code_only' || github.event.inputs.sync_mode }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -t rsa gitee.com >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts

    - name: Setup SSH key with ssh-agent
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.MYGITEE_SSH_PRIVATE_KEY }}
        
    - name: Test SSH Connection
      run: ssh -T git@gitee.com || true

    - name: Setup Git and Verify Tokens
      id: verify_tokens
      run: |
        git config --global user.name "github_bot"
        git config --global user.email "github_bot@github.com"
        
        echo "Verifying GitHub Token and counting repositories..."
        github_repos_count=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
          "https://api.github.com/user/repos?per_page=1" -I | grep -i "link:" | grep -o "page=[0-9]*" | tail -1 | cut -d= -f2)
        if [ -z "$github_repos_count" ]; then
          echo "Error: Unable to get GitHub repositories count. Token may be invalid."
          exit 1
        fi
        echo "Found $github_repos_count repositories on GitHub"
        echo "GITHUB_REPOS_COUNT=$github_repos_count" >> $GITHUB_ENV
        
        echo "Verifying Gitee Token and counting repositories..."
        gitee_repos_count=$(curl -s -H "Authorization: token $GITEE_TOKEN" \
          "https://gitee.com/api/v5/user/repos?per_page=1" -I | grep -i "total_count:" | cut -d: -f2 | tr -d ' \r\n')
        if [ -z "$gitee_repos_count" ]; then
          echo "Error: Unable to get Gitee repositories count. Token may be invalid."
          exit 1
        fi
        echo "Found $gitee_repos_count repositories on Gitee"
        echo "GITEE_REPOS_COUNT=$gitee_repos_count" >> $GITHUB_ENV

    - name: Run Synchronization
      run: |
        # 显示同步统计信息
        echo "============================================"
        echo "开始同步过程 / Starting synchronization process"
        echo "GitHub 仓库数量 / GitHub repositories: $GITHUB_REPOS_COUNT"
        echo "Gitee 仓库数量 / Gitee repositories: $GITEE_REPOS_COUNT"
        echo "需要创建的新仓库数量 / New repositories to create: $(($GITHUB_REPOS_COUNT - $GITEE_REPOS_COUNT))"
        echo "============================================"

        # 定义所有函数
        # 清理函数
        cleanup() {
          local repo_name=$1
          
          echo "清理前磁盘空间 / Disk space before cleanup:"
          df -h /
          
          echo "清理临时文件和目录 / Cleaning up temporary files and directories..."
          
          # 确保回到安全的目录
          cd /tmp
          
          # 清理镜像仓库目录
          local mirror_path="/tmp/$(basename "$repo_name")"
          if [ -d "$mirror_path" ]; then
            echo "清理镜像仓库 / Cleaning mirror repository: $mirror_path"
            rm -rf "$mirror_path"
            if [ -d "$mirror_path" ]; then
              echo "❌ 清理失败，尝试强制删除 / Cleanup failed, trying force delete"
              find "$mirror_path" -delete
            fi
          fi
          
          # 清理同步用的临时目录
          local temp_dir="/tmp/temp_$(basename "$repo_name")"
          if [ -d "$temp_dir" ]; then
            echo "清理同步临时目录 / Cleaning sync temp directory: $temp_dir"
            rm -rf "$temp_dir"
            if [ -d "$temp_dir" ]; then
              echo "❌ 清理失败，尝试强制删除 / Cleanup failed, trying force delete"
              find "$temp_dir" -delete
            fi
          fi
          
          # 清理所有临时文件
          echo "清理其他临时文件 / Cleaning other temporary files..."
          find /tmp -maxdepth 1 -type f \( -name "*.apk" -o -name "*.zip" -o -name "*.tar.gz" -o -name "*.jar" -o -name "*.tmp" \) -delete
          
          echo "清理后磁盘空间 / Disk space after cleanup:"
          df -h /
          
          # 验证清理结果
          if [ -d "$mirror_path" ] || [ -d "$temp_dir" ]; then
            echo "❌ 清理失败，仍有目录未删除 / Cleanup failed, directories still exist"
            return 1
          fi
          
          echo "✅ 清理完成 / Cleanup completed"
          return 0
        }

        # 获取可见引用函数
        get_visible_refs() {
          local ref_type=$1  # "heads" 或 "tags"
          git for-each-ref --format='%(refname)' "refs/${ref_type}/*" | grep -v "refs/pull/" | grep -v "refs/gh-pages/"
        }

        # 检查仓库大小函数
        check_repo_size() {
          local repo_name=$1
          local size_limit_mb=1024  # Gitee 免费版仓库大小限制为 1GB
          
          echo "检查仓库大小 / Checking repository size..."
          
          # 获取仓库大小（以KB为单位）
          local size_kb=$(du -sk "$repo_path" 2>/dev/null | cut -f1)
          if [ -z "$size_kb" ]; then
            echo "⚠️ 无法获取仓库大小 / Unable to get repository size"
            return 0
          fi
          
          # 转换为MB
          local size_mb=$((size_kb / 1024))
          echo "仓库大小 / Repository size: ${size_mb}MB"
          
          if [ $size_mb -gt $size_limit_mb ]; then
            echo "⚠️ 仓库超出 Gitee 免费版大小限制 / Repository exceeds Gitee free tier size limit"
            echo "当前大小 / Current size: ${size_mb}MB"
            echo "限制大小 / Size limit: ${size_limit_mb}MB"
            return 1
          fi
          
          return 0
        }

        # 清理仓库 releases 附件函数
        clean_release_assets() {
          local repo_name=$1
          local owner=${repo_name%/*}
          local repo=${repo_name#*/}
          
          echo "清理仓库 Releases 附件 / Cleaning repository release assets..."
          
          # 获取所有 releases
          local releases=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${repo_name}/releases")
          
          if [ -z "$releases" ] || [ "$(echo "$releases" | jq length)" -eq "0" ]; then
            echo "未找到 Releases / No releases found"
            return 0
          fi
          
          echo "找到 $(echo "$releases" | jq length) 个 Releases / Found $(echo "$releases" | jq length) releases"
          
          # 遍历所有 releases 的附件
          echo "$releases" | jq -c '.[]' | while read -r release; do
            local tag_name=$(echo "$release" | jq -r '.tag_name')
            local assets=$(echo "$release" | jq -c '.assets[]')
            
            if [ -n "$assets" ]; then
              echo "清理 Release ${tag_name} 的附件 / Cleaning assets for release ${tag_name}"
              echo "$assets" | while read -r asset; do
                local asset_id=$(echo "$asset" | jq -r '.id')
                local asset_name=$(echo "$asset" | jq -r '.name')
                local asset_size=$(echo "$asset" | jq -r '.size')
                
                # 转换为MB
                local size_mb=$((asset_size / 1048576))
                echo "附件: ${asset_name} (${size_mb}MB)"
                
                # 删除大于 50MB 的附件
                if [ $size_mb -gt 50 ]; then
                  echo "删除大附件 / Deleting large asset: ${asset_name} (${size_mb}MB)"
                  curl -s -X DELETE -H "Authorization: token $GITHUB_TOKEN" \
                    "https://api.github.com/repos/${repo_name}/releases/assets/${asset_id}"
                fi
              done
            fi
          done
          
          return 0
        }

        # 同步代码函数 - 使用 reset --hard 加速同步
        sync_code() {
          local repo_name=$1
          local repo_path=$2
          local ret=0
          local failed_branches=""
          
          echo "准备同步分支代码 / Preparing to sync branch code..."
          
          # 检查仓库大小
          if ! check_repo_size "$repo_name"; then
            echo "仓库超出大小限制，尝试清理 Releases 附件 / Repository exceeds size limit, attempting to clean release assets..."
            
            # 尝试清理 releases 附件
            if clean_release_assets "$repo_name"; then
              echo "清理完成，重新检查大小 / Cleanup completed, rechecking size..."
              
              # 再次检查大小
              if ! check_repo_size "$repo_name"; then
                echo "❌ 清理后仍超出限制，跳过同步 / Still exceeds limit after cleanup, skipping sync"
                echo "建议：/ Suggestions:"
                echo "1. 升级到 Gitee 企业版 / Upgrade to Gitee Enterprise"
                echo "2. 手动清理大文件 / Manually clean large files"
                return 1
              else
                echo "✅ 清理成功，继续同步 / Cleanup successful, continuing sync"
              fi
            else
              echo "❌ 清理失败，跳过同步 / Cleanup failed, skipping sync"
              return 1
            fi
          fi
          
          # 创建临时目录
          local temp_dir="/tmp/temp_${repo_name##*/}"
          mkdir -p "$temp_dir"
          cd "$temp_dir"
          
          # 初始化仓库并设置远程
          git init
          git remote add gitee "git@gitee.com:${GITEE_USERNAME}/${repo_name##*/}.git"
          git remote add github "https://x-access-token:${GITHUB_TOKEN}@github.com/${repo_name}.git"
          
          # 获取所有分支列表（排除隐藏引用）
          local branches=$(cd "$repo_path" && get_visible_refs "heads" | sed 's|refs/heads/||')
          
          echo "获取到的分支列表 / Fetched branches list:"
          echo "$branches"
          
          # 从 GitHub 获取所有分支
          echo "从 GitHub 获取所有分支 / Fetching all branches from GitHub..."
          git fetch github --quiet
          
          # 遍历处理每个分支
          echo "$branches" | while read branch; do
            if [ -z "$branch" ]; then
              continue
            fi
            
            echo "处理分支 / Processing branch: $branch"
            
            # 重置到 GitHub 分支的最新状态
            if git reset --hard "github/$branch" 2>/dev/null; then
              echo "已重置到最新状态 / Reset to latest state: $branch"
              
              # 强制推送到 Gitee，添加重试机制
              local max_retries=3
              local retry_count=0
              local push_success=false
              
              while [ $retry_count -lt $max_retries ] && [ "$push_success" = "false" ]; do
                if [ $retry_count -gt 0 ]; then
                  echo "第 $((retry_count + 1)) 次尝试推送 / Retry attempt $((retry_count + 1)) for $branch"
                  sleep $((retry_count * 5))
                  
                  # 重试前先获取最新状态
                  echo "获取 Gitee 仓库最新状态 / Fetching latest state from Gitee..."
                  git fetch gitee || true
                fi
                
                # 显示完整的推送命令和错误信息
                echo "执行推送命令 / Executing push command: git push -f gitee HEAD:$branch"
                if push_output=$(git push -f gitee "HEAD:$branch" 2>&1); then
                  echo "✅ 成功同步分支 / Successfully synced branch: $branch"
                  push_success=true
                  break
                else
                  retry_count=$((retry_count + 1))
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⚠️ 推送失败，将重试 / Push failed, will retry: $branch"
                    echo "错误详情 / Error details:"
                    echo "$push_output"
                    
                    # 检查具体错误类型
                    if echo "$push_output" | grep -q "shallow update not allowed"; then
                      echo "检测到浅克隆错误，尝试完整克隆 / Detected shallow clone error, trying full clone..."
                      git fetch github --unshallow || true
                    fi
                  fi
                fi
              done
              
              if [ "$push_success" = "false" ]; then
                echo "❌ 推送分支失败（已重试 $max_retries 次）/ Push failed after $max_retries retries: $branch"
                echo "最后一次错误详情 / Last error details:"
                echo "$push_output"
                failed_branches="$failed_branches\n$branch"
                ret=1
              fi
            else
              echo "❌ 重置分支失败 / Failed to reset branch: $branch"
              echo "错误详情 / Error details:"
              git reset --hard "github/$branch" 2>&1 || true
              failed_branches="$failed_branches\n$branch"
              ret=1
            fi
          done
          
          if [ -n "$failed_branches" ]; then
            echo "----------------------------------------"
            echo "❌ 以下分支同步失败 / Following branches failed to sync:"
            echo -e "$failed_branches"
            echo "----------------------------------------"
          fi
          
          # 返回到原目录
          cd /tmp
          
          return $ret
        }

        # 同步标签函数
        sync_tags() {
          local repo_name=$1
          local repo_path=$2
          local ret=0
          local failed_refs=""
          
          echo "推送标签 / Pushing tags..."
          get_visible_refs "tags" | while read ref; do
            echo "推送标签 / Pushing tag: $ref"
            if ! push_ref "$repo_name" "$ref"; then
              failed_refs="$failed_refs\n$ref"
              ret=1
              continue  # 继续处理其他标签，而不是立即退出
            fi
          done
          
          if [ -n "$failed_refs" ]; then
            echo "----------------------------------------"
            echo "❌ 以下标签推送失败 / Following tags failed to push:"
            echo -e "$failed_refs"
            echo "----------------------------------------"
          fi
          
          return $ret
        }

        # 同步Release附件函数
        sync_releases() {
          local repo_name=$1
          
          echo "检查发布版本 / Checking releases for $repo_name..."
          # 获取GitHub的releases
          local releases=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${repo_name}/releases")
          
          # 检查是否有releases
          if [ "$(echo "$releases" | jq length)" -eq "0" ]; then
            echo "ℹ️ 未找到发布版本 / No releases found for $repo_name"
            return 0
          fi
          
          echo "在 GitHub 上找到 $(echo "$releases" | jq length) 个发布版本 / Found $(echo "$releases" | jq length) release(s) on GitHub"
          
          # 获取Gitee上已存在的releases
          local gitee_releases=$(curl -s -H "Authorization: token $GITEE_TOKEN" \
            "https://gitee.com/api/v5/repos/${GITEE_USERNAME}/${repo_name##*/}/releases?per_page=100")
          local existing_tags=$(echo "$gitee_releases" | jq -r '.[].tag_name' 2>/dev/null || echo "")
          
          # 并行处理releases
          echo "$releases" | jq -c '.[]' | while read -r release; do
            {
              local tag_name=$(echo "$release" | jq -r '.tag_name')
              local name=$(echo "$release" | jq -r '.name // .tag_name')
              local body=$(echo "$release" | jq -r '.body // ""')
              local prerelease=$(echo "$release" | jq -r '.prerelease')
              
              echo "处理发布版本 / Processing release: $tag_name"
              
              # 检查release是否已存在
              if echo "$existing_tags" | grep -q "^${tag_name}$"; then
                echo "ℹ️ 发布版本已存在于 Gitee / Release $tag_name already exists on Gitee"
              else
                process_release "$repo_name" "$tag_name" "$name" "$body" "$prerelease" "$release"
              fi
            } &
            
            # 限制并行数量为3个
            while [ $(jobs -r | wc -l) -ge 3 ]; do
              sleep 1
            done
          done
          
          # 等待所有release处理完成
          wait
          
          return 0
        }

        # 主同步函数
        sync_repo() {
          local repo_name=$1
          local repo_path=$2
          local gitee_repo_exists=$3
          local ret=0
          
          # 确保清理旧的临时文件
          cleanup "$repo_name"
          
          echo "===> 步骤 1: 克隆 GitHub 仓库 / Step 1: Cloning GitHub repository"
          echo "仓库 / Repository: $repo_name"
          
          # 使用完整克隆
          git clone --mirror \
            "https://x-access-token:${GITHUB_TOKEN}@github.com/${repo_name}.git" "$repo_path" || {
            echo "❌ 从 GitHub 克隆仓库失败 / Failed to clone repository from GitHub: $repo_name"
            cleanup "$repo_name"
            return 1
          }
          echo "✅ 成功克隆 GitHub 仓库 / Successfully cloned GitHub repository"
          
          if [ "$gitee_repo_exists" = "false" ]; then
            echo "===> 步骤 2: 在 Gitee 上创建新仓库 / Step 2: Creating new repository on Gitee"
            echo "创建私有仓库 / Creating private repository: ${repo_name##*/}"
            local create_response=$(curl -s -X POST -H "Authorization: token $GITEE_TOKEN" \
              "https://gitee.com/api/v5/user/repos" \
              -d "name=${repo_name##*/}&private=true&has_issues=true&has_wiki=true")
            
            if echo "$create_response" | grep -q "error"; then
              # 检查是否是因为仓库已存在（忽略大小写）
              if echo "$create_response" | grep -q "已存在同地址仓库（忽略大小写）"; then
                echo "⚠️ 仓库已存在（忽略大小写），尝试直接同步 / Repository exists (case-insensitive), trying to sync directly"
                gitee_repo_exists=true
              else
                echo "❌ 在 Gitee 上创建仓库失败 / Failed to create repository on Gitee: ${repo_name##*/}"
                echo "错误 / Error: $(echo "$create_response" | jq -r '.error // .message')"
                cleanup "$repo_name"
                return 1
              fi
            else
              echo "✅ 成功创建 Gitee 仓库 / Successfully created Gitee repository"
              echo "等待仓库创建完成 / Waiting for repository creation to complete..."
              sleep 5
            fi
          fi
          
          echo "===> 步骤 3: 同步到 Gitee / Step 3: Syncing to Gitee"
          
          case "$SYNC_MODE" in
            "code_only")
              echo "仅同步代码 / Syncing code only..."
              sync_code "$repo_name" "$repo_path"
              ret=$?
              ;;
            "code_and_tags")
              echo "同步代码和标签 / Syncing code and tags..."
              sync_code "$repo_name" "$repo_path" && sync_tags "$repo_name" "$repo_path"
              ret=$?
              ;;
            "code_tags_and_assets")
              echo "同步代码、标签和附件 / Syncing code, tags and assets..."
              sync_code "$repo_name" "$repo_path" && \
              sync_tags "$repo_name" "$repo_path" && \
              sync_releases "$repo_name"
              ret=$?
              ;;
          esac
          
          # 同步完成后清理
          if ! cleanup "$repo_name"; then
            echo "❌ 清理失败 / Cleanup failed"
            ret=1
          fi
          
          return $ret
        }

        # 导出所有函数到环境变量中
        declare -fx cleanup
        declare -fx get_visible_refs
        declare -fx check_repo_size
        declare -fx clean_release_assets
        declare -fx sync_code
        declare -fx sync_tags
        declare -fx sync_releases
        declare -fx sync_repo

        # 并行处理仓库
        process_repo() {
          local repo_name=$1
          local repo_path=$2
          local gitee_repo_exists=$3
          local repo_num=$4
          local total=$5
          
          echo "========== 开始处理仓库 $repo_num/$total: $repo_name =========="
          
          if sync_repo "$repo_name" "$repo_path" "$gitee_repo_exists"; then
            echo "========== ✅ 成功同步仓库 $repo_num/$total: $repo_name =========="
            success_count=$((success_count + 1))
            return 0
          else
            echo "========== ❌ 同步仓库失败 $repo_num/$total: $repo_name =========="
            failed_count=$((failed_count + 1))
            return 1
          fi
        }
        declare -fx process_repo

        # 主程序开始
        processed=0
        total=$GITHUB_REPOS_COUNT
        page=1
        success_count=0
        failed_count=0
        max_concurrent_syncs=2  # 减少并行数量，避免日志混乱
        
        echo "开始仓库同步 / Starting repository synchronization..."
        
        while true; do
          echo "获取第 $page 页仓库 / Fetching page $page of repositories..."
          repos=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/user/repos?per_page=100&page=${page}")
          
          # 检查是否还有仓库
          if [ "$(echo "$repos" | jq length)" -eq "0" ]; then
            echo "没有更多仓库需要处理 / No more repositories to process"
            break
          fi
          
          # 获取Gitee现有仓库列表
          echo "获取 Gitee 仓库列表 / Fetching Gitee repository list..."
          gitee_repos=$(curl -s -H "Authorization: token $GITEE_TOKEN" \
            "https://gitee.com/api/v5/user/repos?per_page=100" | jq -r '.[].name')
          
          # 并行处理仓库
          echo "$repos" | jq -r '.[] | .full_name' | while read -r repo_name; do
            # 等待，直到运行中的任务数小于最大并行数
            while [ $(jobs -r | wc -l) -ge $max_concurrent_syncs ]; do
              sleep 1
            done
            
            repo_path="/tmp/$(basename "$repo_name")"
            processed=$((processed + 1))
            
            # 检查仓库是否已存在于Gitee
            if echo "$gitee_repos" | grep -q "^$(basename "$repo_name")$"; then
              echo "仓库已存在于 Gitee / Repository exists on Gitee: ${repo_name##*/}"
              gitee_repo_exists=true
            else
              echo "仓库不存在于 Gitee / Repository does not exist on Gitee: ${repo_name##*/}"
              gitee_repo_exists=false
            fi
            
            # 在后台运行同步任务
            process_repo "$repo_name" "$repo_path" "$gitee_repo_exists" "$processed" "$total" &
            
            # 添加短暂延迟，避免日志混乱
            sleep 2
          done
          
          # 等待当前页的所有任务完成
          wait
          
          page=$((page + 1))
        done
        
        echo "============================================"
        echo "同步完成 / Synchronization completed"
        echo "处理的仓库总数 / Total repositories processed: $processed"
        echo "成功数量 / Successful: $success_count"
        echo "失败数量 / Failed: $failed_count"
        echo "============================================"
        
        # 如果有失败的仓库，返回非零状态码
        [ "$failed_count" -eq 0 ]

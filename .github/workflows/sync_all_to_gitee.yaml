name: Sync All Repos to Gitee
# 同步功能模块化：
# 将代码同步、标签同步和附件同步功能拆分为独立函数：
# sync_code(): 只同步分支代码
# sync_tags(): 只同步标签
# sync_releases(): 同步发布版本和附件
# 触发方式和同步模式：
# 自动触发（schedule）：
# 每3天自动执行一次
# 默认只同步代码（SYNC_MODE=code_only）
# 手动触发（workflow_dispatch）：
# 提供三种同步模式选项：
# code_only: 只同步源码
# code_and_tags: 同步源码和标签
# code_tags_and_assets: 同步源码、标签和附件
on:
  workflow_dispatch:
    inputs:
      sync_mode:
        description: '同步模式 / Sync Mode'
        required: true
        default: 'code_only'
        type: choice
        options:
        - code_only
        - code_and_tags
        - code_tags_and_assets
  schedule:
    - cron: '0 0 */3 * *'  # 每3天执行一次

# MYGITEE_TOKEN 是 gitee 的 token
# MYGITEE_USERNAME 是 gitee 的 用户名
# MYGITHUB_TOKEN 是 github 的 token
jobs:
  sync-to-gitee:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.MYGITHUB_TOKEN }}
      GITEE_TOKEN: ${{ secrets.MYGITEE_TOKEN }}
      GITEE_USERNAME: ${{ secrets.MYGITEE_USERNAME }}
      # 设置同步模式：自动触发时只同步代码
      SYNC_MODE: ${{ github.event_name == 'schedule' && 'code_only' || github.event.inputs.sync_mode }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Setup SSH key
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -t rsa gitee.com >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts

    - name: Setup SSH key with ssh-agent
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ secrets.MYGITEE_SSH_PRIVATE_KEY }}
        
    - name: Test SSH Connection
      run: ssh -T git@gitee.com || true

    - name: Setup Git and Verify Tokens
      id: verify_tokens
      run: |
        git config --global user.name "github_bot"
        git config --global user.email "github_bot@github.com"
        
        echo "Verifying GitHub Token and counting repositories..."
        github_repos_count=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
          "https://api.github.com/user/repos?per_page=1" -I | grep -i "link:" | grep -o "page=[0-9]*" | tail -1 | cut -d= -f2)
        if [ -z "$github_repos_count" ]; then
          echo "Error: Unable to get GitHub repositories count. Token may be invalid."
          exit 1
        fi
        echo "Found $github_repos_count repositories on GitHub"
        echo "GITHUB_REPOS_COUNT=$github_repos_count" >> $GITHUB_ENV
        
        echo "Verifying Gitee Token and counting repositories..."
        gitee_repos_count=$(curl -s -H "Authorization: token $GITEE_TOKEN" \
          "https://gitee.com/api/v5/user/repos?per_page=1" -I | grep -i "total_count:" | cut -d: -f2 | tr -d ' \r\n')
        if [ -z "$gitee_repos_count" ]; then
          echo "Error: Unable to get Gitee repositories count. Token may be invalid."
          exit 1
        fi
        echo "Found $gitee_repos_count repositories on Gitee"
        echo "GITEE_REPOS_COUNT=$gitee_repos_count" >> $GITHUB_ENV

    - name: Run Synchronization
      run: |
        # 显示同步统计信息
        echo "============================================"
        echo "开始同步过程 / Starting synchronization process"
        echo "GitHub 仓库数量 / GitHub repositories: $GITHUB_REPOS_COUNT"
        echo "Gitee 仓库数量 / Gitee repositories: $GITEE_REPOS_COUNT"
        echo "需要创建的新仓库数量 / New repositories to create: $(($GITHUB_REPOS_COUNT - $GITEE_REPOS_COUNT))"
        echo "============================================"

        # 定义所有函数
        # 清理函数
        cleanup() {
          local repo_name=$1
          
          echo "清理前磁盘空间 / Disk space before cleanup:"
          df -h /tmp
          
          echo "清理临时文件和目录 / Cleaning up temporary files and directories..."
          
          # 清理镜像仓库目录
          local mirror_path="/tmp/$(basename "$repo_name")"
          if [ -d "$mirror_path" ]; then
            echo "清理镜像仓库 / Cleaning mirror repository: $mirror_path"
            cd "$mirror_path"
            git gc --prune=now
            cd ..
            rm -rf "$mirror_path"
          fi
          
          # 清理同步用的临时目录
          local temp_dir="/tmp/temp_$(basename "$repo_name")"
          if [ -d "$temp_dir" ]; then
            echo "清理同步临时目录 / Cleaning sync temp directory: $temp_dir"
            rm -rf "$temp_dir"
          fi
          
          # 清理所有临时文件
          echo "清理其他临时文件 / Cleaning other temporary files..."
          rm -f /tmp/*.{apk,zip,tar.gz,jar,tmp} 2>/dev/null || true
          
          echo "清理后磁盘空间 / Disk space after cleanup:"
          df -h /tmp
          echo "✅ 清理完成 / Cleanup completed"
        }

        # 获取可见引用函数
        get_visible_refs() {
          local ref_type=$1  # "heads" 或 "tags"
          git for-each-ref --format='%(refname)' "refs/${ref_type}/*" | grep -v "refs/pull/" | grep -v "refs/gh-pages/"
        }

        # 同步代码函数 - 使用 reset --hard 加速同步
        sync_code() {
          local repo_name=$1
          local repo_path=$2
          local ret=0
          local failed_branches=""
          
          echo "准备同步分支代码 / Preparing to sync branch code..."
          
          # 创建临时目录
          local temp_dir="/tmp/temp_${repo_name##*/}"
          mkdir -p "$temp_dir"
          cd "$temp_dir"
          
          # 初始化仓库并设置远程
          git init
          git remote add gitee "git@gitee.com:${GITEE_USERNAME}/${repo_name##*/}.git"
          git remote add github "https://x-access-token:${GITHUB_TOKEN}@github.com/${repo_name}.git"
          
          # 获取所有分支列表（排除隐藏引用）
          local branches=$(cd "$repo_path" && get_visible_refs "heads" | sed 's|refs/heads/||')
          
          echo "获取到的分支列表 / Fetched branches list:"
          echo "$branches"
          
          # 从 GitHub 获取所有分支
          echo "从 GitHub 获取所有分支 / Fetching all branches from GitHub..."
          git fetch github --quiet
          
          # 遍历处理每个分支
          echo "$branches" | while read branch; do
            if [ -z "$branch" ]; then
              continue
            fi
            
            echo "处理分支 / Processing branch: $branch"
            
            # 重置到 GitHub 分支的最新状态
            if git reset --hard "github/$branch" 2>/dev/null; then
              echo "已重置到最新状态 / Reset to latest state: $branch"
              
              # 强制推送到 Gitee
              if timeout 300 git push -f gitee "HEAD:$branch" 2>/dev/null; then
                echo "✅ 成功同步分支 / Successfully synced branch: $branch"
              else
                echo "❌ 推送分支失败 / Failed to push branch: $branch"
                failed_branches="$failed_branches\n$branch"
                ret=1
              fi
            else
              echo "❌ 重置分支失败 / Failed to reset branch: $branch"
              failed_branches="$failed_branches\n$branch"
              ret=1
            fi
          done
          
          if [ -n "$failed_branches" ]; then
            echo "----------------------------------------"
            echo "❌ 以下分支同步失败 / Following branches failed to sync:"
            echo -e "$failed_branches"
            echo "----------------------------------------"
          fi
          
          # 返回到原目录
          cd ..
          
          return $ret
        }

        # 同步标签函数
        sync_tags() {
          local repo_name=$1
          local repo_path=$2
          local ret=0
          local failed_refs=""
          
          echo "推送标签 / Pushing tags..."
          get_visible_refs "tags" | while read ref; do
            echo "推送标签 / Pushing tag: $ref"
            if ! push_ref "$repo_name" "$ref"; then
              failed_refs="$failed_refs\n$ref"
              ret=1
              continue  # 继续处理其他标签，而不是立即退出
            fi
          done
          
          if [ -n "$failed_refs" ]; then
            echo "----------------------------------------"
            echo "❌ 以下标签推送失败 / Following tags failed to push:"
            echo -e "$failed_refs"
            echo "----------------------------------------"
          fi
          
          return $ret
        }

        # 同步Release附件函数
        sync_releases() {
          local repo_name=$1
          
          echo "检查发布版本 / Checking releases for $repo_name..."
          # 获取GitHub的releases
          local releases=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${repo_name}/releases")
          
          # 检查是否有releases
          if [ "$(echo "$releases" | jq length)" -eq "0" ]; then
            echo "ℹ️ 未找到发布版本 / No releases found for $repo_name"
            return 0
          fi
          
          echo "在 GitHub 上找到 $(echo "$releases" | jq length) 个发布版本 / Found $(echo "$releases" | jq length) release(s) on GitHub"
          
          # 获取Gitee上已存在的releases
          local gitee_releases=$(curl -s -H "Authorization: token $GITEE_TOKEN" \
            "https://gitee.com/api/v5/repos/${GITEE_USERNAME}/${repo_name##*/}/releases?per_page=100")
          local existing_tags=$(echo "$gitee_releases" | jq -r '.[].tag_name' 2>/dev/null || echo "")
          
          # 并行处理releases
          echo "$releases" | jq -c '.[]' | while read -r release; do
            {
              local tag_name=$(echo "$release" | jq -r '.tag_name')
              local name=$(echo "$release" | jq -r '.name // .tag_name')
              local body=$(echo "$release" | jq -r '.body // ""')
              local prerelease=$(echo "$release" | jq -r '.prerelease')
              
              echo "处理发布版本 / Processing release: $tag_name"
              
              # 检查release是否已存在
              if echo "$existing_tags" | grep -q "^${tag_name}$"; then
                echo "ℹ️ 发布版本已存在于 Gitee / Release $tag_name already exists on Gitee"
              else
                process_release "$repo_name" "$tag_name" "$name" "$body" "$prerelease" "$release"
              fi
            } &
            
            # 限制并行数量为3个
            while [ $(jobs -r | wc -l) -ge 3 ]; do
              sleep 1
            done
          done
          
          # 等待所有release处理完成
          wait
          
          return 0
        }

        # 主同步函数
        sync_repo() {
          local repo_name=$1
          local repo_path=$2
          local gitee_repo_exists=$3
          local ret=0
          
          echo "===> 步骤 1: 克隆 GitHub 仓库 / Step 1: Cloning GitHub repository"
          echo "仓库 / Repository: $repo_name"
          
          # 使用完整克隆
          git clone --mirror \
            "https://x-access-token:${GITHUB_TOKEN}@github.com/${repo_name}.git" "$repo_path" || {
            echo "❌ 从 GitHub 克隆仓库失败 / Failed to clone repository from GitHub: $repo_name"
            return 1
          }
          echo "✅ 成功克隆 GitHub 仓库 / Successfully cloned GitHub repository"
          
          if [ "$gitee_repo_exists" = "false" ]; then
            echo "===> 步骤 2: 在 Gitee 上创建新仓库 / Step 2: Creating new repository on Gitee"
            echo "创建私有仓库 / Creating private repository: ${repo_name##*/}"
            local create_response=$(curl -s -X POST -H "Authorization: token $GITEE_TOKEN" \
              "https://gitee.com/api/v5/user/repos" \
              -d "name=${repo_name##*/}&private=true&has_issues=true&has_wiki=true")
            
            if echo "$create_response" | grep -q "error"; then
              echo "❌ 在 Gitee 上创建仓库失败 / Failed to create repository on Gitee: ${repo_name##*/}"
              echo "错误 / Error: $(echo "$create_response" | jq -r '.error // .message')"
              ret=1
            else
              echo "✅ 成功创建 Gitee 仓库 / Successfully created Gitee repository"
            fi
            
            echo "等待仓库创建完成 / Waiting for repository creation to complete..."
            sleep 5
          fi
          
          if [ $ret -eq 0 ]; then
            echo "===> 步骤 3: 同步到 Gitee / Step 3: Syncing to Gitee"
            
            case "$SYNC_MODE" in
              "code_only")
                echo "仅同步代码 / Syncing code only..."
                sync_code "$repo_name" "$repo_path"
                ;;
              "code_and_tags")
                echo "同步代码和标签 / Syncing code and tags..."
                sync_code "$repo_name" "$repo_path" && sync_tags "$repo_name" "$repo_path"
                ;;
              "code_tags_and_assets")
                echo "同步代码、标签和附件 / Syncing code, tags and assets..."
                sync_code "$repo_name" "$repo_path" && \
                sync_tags "$repo_name" "$repo_path" && \
                sync_releases "$repo_name"
                ;;
            esac
          fi
          
          # 确保在函数内部调用 cleanup
          cleanup "$repo_name"
          return $ret
        }

        # 导出所有函数到环境变量中
        declare -fx cleanup
        declare -fx get_visible_refs
        declare -fx sync_code
        declare -fx sync_tags
        declare -fx sync_releases
        declare -fx sync_repo

        # 并行处理仓库
        process_repo() {
          local repo_name=$1
          local repo_path=$2
          local gitee_repo_exists=$3
          
          if sync_repo "$repo_name" "$repo_path" "$gitee_repo_exists"; then
            echo "✅ 成功同步仓库 / Successfully synced repository: $repo_name"
            return 0
          else
            echo "❌ 同步仓库失败 / Failed to sync repository: $repo_name"
            return 1
          fi
        }
        declare -fx process_repo

        # 主程序开始
        processed=0
        total=$GITHUB_REPOS_COUNT
        page=1
        success_count=0
        failed_count=0
        max_concurrent_syncs=3  # 最大并行同步数量
        
        echo "开始仓库同步 / Starting repository synchronization..."
        
        while true; do
          echo "获取第 $page 页仓库 / Fetching page $page of repositories..."
          repos=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/user/repos?per_page=100&page=${page}")
          
          # 检查是否还有仓库
          if [ "$(echo "$repos" | jq length)" -eq "0" ]; then
            echo "没有更多仓库需要处理 / No more repositories to process"
            break
          fi
          
          # 获取Gitee现有仓库列表
          echo "获取 Gitee 仓库列表 / Fetching Gitee repository list..."
          gitee_repos=$(curl -s -H "Authorization: token $GITEE_TOKEN" \
            "https://gitee.com/api/v5/user/repos?per_page=100" | jq -r '.[].name')
          
          # 并行处理仓库
          echo "$repos" | jq -r '.[] | .full_name' | while read -r repo_name; do
            # 等待，直到运行中的任务数小于最大并行数
            while [ $(jobs -r | wc -l) -ge $max_concurrent_syncs ]; do
              sleep 1
            done
            
            repo_path="/tmp/$(basename "$repo_name")"
            
            echo "----------------------------------------"
            echo "处理第 $((processed + 1)) 个，共 $total 个 / Processing $((processed + 1)) of $total: $repo_name"
            
            # 检查仓库是否已存在于Gitee
            if echo "$gitee_repos" | grep -q "^$(basename "$repo_name")$"; then
              echo "仓库已存在于 Gitee / Repository exists on Gitee: ${repo_name##*/}"
              gitee_repo_exists=true
            else
              echo "仓库不存在于 Gitee / Repository does not exist on Gitee: ${repo_name##*/}"
              gitee_repo_exists=false
            fi
            
            # 在后台运行同步任务
            process_repo "$repo_name" "$repo_path" "$gitee_repo_exists" &
            
            processed=$((processed + 1))
          done
          
          # 等待当前页的所有任务完成
          wait
          
          page=$((page + 1))
        done
        
        echo "============================================"
        echo "同步完成 / Synchronization completed"
        echo "处理的仓库总数 / Total repositories processed: $processed"
        echo "成功数量 / Successful: $success_count"
        echo "失败数量 / Failed: $failed_count"
        echo "============================================"
        
        # 如果有失败的仓库，返回非零状态码
        [ "$failed_count" -eq 0 ]
